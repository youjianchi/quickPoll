# QuickPoll (React + Node + Supabase)

QuickPoll is a full-stack polling app: a Vite + React client backed by a lightweight Node/Express API that talks to Supabase. Authenticated users can create polls, anyone can find a poll by ID, and voting stays open to all visitors. The repository is set up with GitHub Actions for CI, GitHub Pages for the static frontend, and a manual backend packaging workflow so you can roll releases forward or backward on demand.

```
quickpoll/
├─ client/          # Vite + React SPA
├─ server/          # Node/Express API (Supabase integration + auth)
├─ .github/workflows
│   ├─ ci.yml                 # Frontend + backend lint/test/build pipeline
│   ├─ pages.yml              # GitHub Pages deployment (workflow_dispatch supports rollbacks)
│   └─ backend-package.yml    # Produces a deployable backend bundle for any ref
└─ .env.example     # Backend environment template
```

## 1. Prepare Supabase

1. Create (or reuse) a Supabase project and grab the **Project URL**, **anon key**, and **service role key** from **Project Settings → API**.
2. In the SQL editor, run the script below to create the schema, enable Row Level Security, and expose the RPC used by the API:

   ```sql
   -- Core tables
   create table if not exists polls (
     id bigint generated by default as identity primary key,
     question text not null,
     created_at timestamptz not null default timezone('utc', now()),
     created_by uuid references auth.users(id)
   );

   create table if not exists options (
     id bigint generated by default as identity primary key,
     poll_id bigint not null references polls(id) on delete cascade,
     text text not null,
     votes integer not null default 0
   );

   -- Row Level Security
   alter table polls enable row level security;
   alter table options enable row level security;

   create policy "Polls are readable by everyone" on polls
     for select using (true);

   create policy "Options are readable by everyone" on options
     for select using (true);

   -- Poll creation and voting happen through the backend using the service role key.

   create or replace function vote_on_option(input_poll_id bigint, input_option_id bigint)
   returns boolean
   language plpgsql
   security definer
   set search_path = public
   as $$
   declare
     updated integer;
   begin
     update options
     set votes = votes + 1
     where id = input_option_id and poll_id = input_poll_id;

     get diagnostics updated = row_count;
     return updated > 0;
   end;
   $$;

   grant execute on function vote_on_option(bigint, bigint) to anon;
   ```

> ⚠️ For production tighten the policies to your requirements. The backend currently uses the Supabase service role key, so RLS is bypassed for writes performed by the server.

## 2. Configure environment variables

### Backend (`server/.env`)

Copy the example file and populate the values from Supabase:

```bash
cp .env.example .env
```

| Variable                     | Description                                                     |
| --------------------------- | --------------------------------------------------------------- |
| `SUPABASE_URL`              | Supabase project URL (e.g. `https://xyz.supabase.co`).          |
| `SUPABASE_SERVICE_ROLE_KEY` | Service role key (only the backend should use this).            |
| `SUPABASE_ANON_KEY`         | Public anon key (used for sign-in).                             |
| `CLIENT_ORIGIN`             | Comma separated list of allowed frontend origins for CORS.      |
| `PORT` *(optional)*         | Port for the API (defaults to `4000`).                          |

### Frontend (`client/.env`)

```bash
cd client
cp .env.example .env
```

| Variable             | Description                                             |
| ------------------- | ------------------------------------------------------- |
| `VITE_API_BASE_URL` | URL where the Node API will run (e.g. `http://localhost:4000`). |

## 3. Run the stack locally

In one terminal, start the backend:

```bash
cd server
npm install
npm run dev   # starts Express on http://localhost:4000
```

In a second terminal, start the frontend:

```bash
cd client
npm install
npm run dev   # launches Vite on http://localhost:5173
```

Sign up with an email + password, confirm the email via Supabase if required, sign in, and you can now create polls. Anonymous visitors can still fetch a poll by ID and vote.

### Quality checks

```bash
cd client
npm run lint
npm run test

cd ../server
npm run lint
npm run test
```

### Production builds

- Frontend: `cd client && npm run build` (output in `client/dist`).
- Backend: `cd server && npm install --omit=dev` for a production install.

## 4. Continuous Integration & Delivery

- **CI (`.github/workflows/ci.yml`)** — Runs on every push/PR to `main`, linting + testing both the frontend and backend. The frontend also performs a production build.
- **Frontend deploy (`.github/workflows/pages.yml`)** — Publishes the static site to GitHub Pages after CI succeeds. The workflow supports manual runs with a `ref` input, so you can redeploy any historical commit (handy for rollbacks).
- **Backend package (`.github/workflows/backend-package.yml`)** — Manual workflow that installs dependencies, runs tests, and uploads a tarball containing the server (with production dependencies). Provide a `ref` when dispatching to roll out or roll back to a specific commit. Deploy the tarball to your hosting provider of choice (Railway, Render, Fly, etc.).

### Required repository secrets/variables

Add these in **Settings → Secrets and variables → Actions**:

| Name | Location | Used by |
| ---- | -------- | ------- |
| `SUPABASE_URL` | Secret | Backend CI + packaging |
| `SUPABASE_SERVICE_ROLE_KEY` | Secret | Backend CI + packaging |
| `SUPABASE_ANON_KEY` | Secret | Backend CI + packaging |
| `VITE_API_BASE_URL` | Variable | Frontend CI + GitHub Pages build (URL of your deployed API) |

> The GitHub Pages workflow defaults to `https://api.example.com` if `VITE_API_BASE_URL` is not configured, but production deployments should point to your live backend.

## 5. Rollout & rollback strategy

1. Push changes to a feature branch, open a PR, and let the `CI` workflow validate both apps.
2. Merge to `main` when ready. CI will rerun and GitHub Pages will build the latest frontend bundle.
3. Deploy the backend by triggering **Actions → Package Backend** (optional `ref` input allows deploying a specific commit).
4. If you need to roll back:
   - Re-run **Package Backend** with the previous commit SHA to redeploy the prior backend bundle.
   - Trigger **Deploy to GitHub Pages → Run workflow** with the same commit SHA to republish the earlier frontend.

Both workflows keep recent artifacts so you can download and redeploy manually if needed.

## Common Troubleshooting

- **401 when creating polls**: You must be signed in; if your session expired the app prompts you to sign in again.
- **API CORS errors**: Update `CLIENT_ORIGIN` in `.env` (and redeploy the backend) to include the URL of your frontend.
- **Email confirmations**: Supabase requires email confirmation by default. Complete the confirmation step before signing in.
- **Schema mismatches**: Ensure you added the `created_by` column and re-ran the SQL migration above. Stale tables will cause inserts to fail.
- **GitHub Pages pointing at the wrong API**: Set `VITE_API_BASE_URL` as a repository variable so builds target your deployed backend.

Happy polling! With the backend in place you can continue iterating on richer poll logic while keeping CI/CD guardrails in place.
